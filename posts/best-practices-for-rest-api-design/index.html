<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>翻译|REST API 设计最佳实践</title>
<meta charset=utf-8><meta name=description content="Ladder@在这篇文章中，我们将探讨如何设计 REST API，使其对任何使用它们的人来说都是容易理解的，是面向未来的，并且是安全和快速的，因为它们为可能是机密的客户提供数据。"><meta name=author content="Jinglue"><link rel=canonical href=https://blog.batkiz.com/posts/best-practices-for-rest-api-design/><link rel=alternate type=application/rss+xml href=https://blog.batkiz.com//index.xml title="not b@tk1z"><meta property="og:title" content="翻译|REST API 设计最佳实践"><meta property="og:description" content="在这篇文章中，我们将探讨如何设计 REST API，使其对任何使用它们的人来说都是容易理解的，是面向未来的，并且是安全和快速的，因为它们为可能是机密的客户提供数据。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.batkiz.com/posts/best-practices-for-rest-api-design/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-18T18:51:25+08:00"><meta property="article:modified_time" content="2021-03-18T18:51:25+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="翻译|REST API 设计最佳实践"><meta name=twitter:description content="在这篇文章中，我们将探讨如何设计 REST API，使其对任何使用它们的人来说都是容易理解的，是面向未来的，并且是安全和快速的，因为它们为可能是机密的客户提供数据。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"翻译|REST API 设计最佳实践","item":"https://blog.batkiz.com/posts/best-practices-for-rest-api-design/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"翻译|REST API 设计最佳实践","name":"翻译|REST API 设计最佳实践","description":"在这篇文章中，我们将探讨如何设计 REST API，使其对任何使用它们的人来说都是容易理解的，是面向未来的，并且是安全和快速的，因为它们为可能是机密的客户提供数据。","keywords":["翻译","stackoverflow"],"articleBody":"原文链接：Best practices for REST API design\n译者按：关于 REST API 的介绍与最佳实践，亦可参见微软 Web API 设计。\n声明：本文的完成亦有 DeepL 的帮助。\nREST API 是现今最常见的网络服务之一。它允许包括浏览器在内的多种客户端通过 REST API 与服务器进行通信。\n因此，正确地设计 REST API 非常重要，这样我们就不会在后续的道路上出现问题。我们必须考虑到 API 用户的账号安全性、性能和易用性。\n否则，我们就会给使用我们 API 的客户们带来问题，这并不令人愉快，也会影响人们使用我们的 API。如果我们不遵循普遍接受的惯例，那么我们就会给 API 的维护者和使用它们的客户带来困扰，因为它与大家所期望的不同。\n在这篇文章中，我们将探讨如何设计 REST API，使其对任何使用它们的人来说都是容易理解的，是不会过时的，并且是安全和快速的，因为它们向客户提供的数据可能是保密的。\n由于网络应用可能会被多种问题破坏，我们应该确保任何 REST API 都应使用标准的 HTTP 状态码，以优雅地处理错误，帮助用户处理问题。\n用 JSON 接收与响应 REST API 应该接收 JSON 作为请求的有效载荷（payload），同时也应以 JSON 发送响应。JSON 是传输数据的标准。几乎所有的网络技术都可以使用它：JavaScript 有内置的方法，可以通过 Fetch API 或其他 HTTP 客户端对 JSON 进行编码和解码。服务器端的技术也有一些库可以解码 JSON，不需要做太多工作。\n当然，还有其他传输数据的方式。XML 并没有得到框架的广泛支持，其常用替代通常是 JSON。我们在客户端——尤其是在浏览器中——不能特别容易地操作这些数据。光是做正常的数据传输就会有很多额外的工作。\n表单数据（form data）很适合用于发送数据，特别是当我们要发送文件时。但是对于文本和数字，我们不需要表单数据来传输这些，因为——对大多数框架来说——我们只需要在客户端直接从中获取数据就可以传输 JSON。这是到目前为止最直接的做法。\n为了确保当我们的 REST API 应用以 JSON 响应时，客户端会将其解释为 JSON，我们应该在请求发出后，将响应头（header）中的 Content-Type 设置为 application/json。很多服务器端应用框架都会自动设置响应头。一些 HTTP 客户端会根据 Content-Type 响应头来解析数据。\n唯一的例外是，如果我们试图在客户端和服务器之间发送和接收文件。那么我们就需要处理文件响应，从客户端向服务器发送表单数据。但这就是另外一个话题了。\n我们还应该确保我们的端点（endpoint）能够返回 JSON 作为响应。许多服务器端框架都将此作为一个内置功能。\n让我们来看看一个接受 JSON payload 的 API 示例。这个例子将使用 Node.js 的 Express 后端框架。我们可以使用 body-parser 中间件 来解析 JSON 请求体，然后我们可以调用 res.json 方法，将我们想要返回的对象构造为 JSON 响应，如下所示。\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const app = express(); app.use(bodyParser.json()); app.post(\"/\", (req, res) =\u003e { res.json(req.body); }); app.listen(3000, () =\u003e console.log(\"server started\")); bodyParser.json() 将 JSON 请求体字符串解析为 JavaScript 对象，然后将其分配给 req.body 对象。\n将响应中的 Content-Type 头设置为 application/json; charset=utf-8，不要做任何修改。这个方法适用于大多数其他后端框架。\n在端点路径中使用名词而非动词 我们不应该在端点路径中使用动词。相反，我们应该使用名词作为路径名，该名词应代表我们要检索或操作的端点的实体。\n这是因为我们的 HTTP 请求方法已经在用动词了。在我们的 API 端点路径中使用动词并没有益处，而且会使它变得不必要的长，因为它没有传达任何新的信息。选择的动词可以根据开发者的想法而变化。比如说，有些人喜欢用 “get”，有些人喜欢用 “retrieve”，所以让 HTTP GET 动词告诉我们什么和端点做什么就好了。\n动作应该由我们所做的 HTTP 请求方法来表示。最常见的方法包括 GET、POST、PUT 和 DELETE。\nGET 检索资源。POST 向服务器提交新数据。PUT 更新现有数据。DELETE 删除数据。这些动词映射到 CRUD 操作。\n考虑到我们上面讨论的两个原则，我们应该创建像 GET /articles/ 这样的路由来获取新闻文章。同样，POST /articles/ 用于添加新的文章，PUT /articles/:id 用于用给定的 id 更新文章。DELETE /articles/:id 用于删除给定 ID 的现有文章。\n/articles 代表一个 REST API 资源。例如，我们可以使用 Express 添加以下端点来操作文章，如下所示。\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const app = express(); app.use(bodyParser.json()); app.get(\"/articles\", (req, res) =\u003e { const articles = []; // 获取文章的代码 res.json(articles); }); app.post(\"/articles\", (req, res) =\u003e { // 添加新文章的代码 res.json(req.body); }); app.put(\"/articles/:id\", (req, res) =\u003e { const { id } = req.params; // 更新文章的代码 res.json(req.body); }); app.delete(\"/articles/:id\", (req, res) =\u003e { const { id } = req.params; // 删除文章的代码 res.json({ deleted: id }); }); app.listen(3000, () =\u003e console.log(\"server started\")); 在上面的代码中，我们定义了操作文章的端点。我们可以看到，路径名中没有任何动词。所有的都是名词。动词在 HTTP 动词中。\nPOST、PUT 和 DELETE 端点都以 JSON 作为请求体，也都以 JSON 作为响应返回，包括 GET 端点。\n使用名词复数来命名集合 我们应该用名词复数来命名集合。我们通常不会只想得到一个单项，所以我们的命名应该是一致的，我们应该用名词复数。\n我们使用名词复数是为了和我们数据库中的内容保持一致。表通常有多个条目，并且在命名时会反映这一点，所以为了与它们保持一致，我们应该使用与 API 访问的表相同的语言。\n对于 /articles 端点，我们的所有端点都是复数形式，所以我们不必将其改为复数。（译者注：此处似乎指的是上面代码之中的端点）\n分层对象的资源嵌套 在处理嵌套资源的端点的路径时，应把嵌套资源追加为父资源后面的路径上。\n我们必须确保我们考虑的嵌套资源与我们数据库表中的资源相匹配。否则会非常混乱。\n比如说，如果我们想要一个端点来获取一篇新闻文章的评论，我们应该将 /comments 追加到 /articles 路径的末尾。这假设了我们在数据库中把评论（comments）作为文章（articles）的一个子节点。\n例如，我们可以在 Express 中使用以下代码来实现。\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const app = express(); app.use(bodyParser.json()); app.get(\"/articles/:articleId/comments\", (req, res) =\u003e { const { articleId } = req.params; const comments = []; // 通过 articleId 获取评论的代码 res.json(comments); }); app.listen(3000, () =\u003e console.log(\"server started\")); 在上面的代码中，我们可以在路径 '/articles/:articleId/comments' 上使用 GET 方法。我们获取由 articleId 标识的文章的评论，然后在响应中返回。我们在 '/articles/:articleId' 路径后添加 'comments'，以表明它是 /articles 的子资源。\n这是有意义的，因为评论（comments）是文章的子对象，假设每篇文章都有自己的评论。否则，就会让用户感到困惑，因为这个结构一般被认为是用来访问子对象的。同样的原理也适用于 POST、PUT 和 DELETE 端点。它们的路径名都可以使用同一种嵌套结构。\n优雅地处理错误并返回标准的错误代码 为了消除 API 用户在发生错误时的困惑，我们应该优雅地处理错误，并返回 HTTP 响应代码，说明发生了什么样的错误。这样可以让 API 的维护者有足够的信息来了解发生的问题。我们不希望错误使我们的系统崩溃，所以我们可以不处理它们，这意味着 API 消费者必须处理它们。\n常见的错误 HTTP 状态码包括：\n400 Bad Request - 这意味着客户端的输入没有通过验证。 401 Unauthorized - 这意味着用户没有被授权访问资源。它通常在用户未认证时返回。 403 Forbidden - 这表示用户已通过认证，但不允许访问资源。 404 Not Found - 这表示找不到资源。 500 Internal server error - 这是一个通用的服务器错误。它可能不应该被明确地抛出。 502 Bad Gateway - 这表示上游服务器发来了无效响应。 503 Service Unavailable - 这表示在服务器端发生了一些意想不到的事情（可能是任何事情，比如服务器过载，系统的某些部分失效，等等）。 我们抛出的错误应该与我们的应用所遇到的问题相对应。例如，如果我们想拒绝请求 payload 中的数据，那么我们应该在 Express API 中返回一个 400 响应，如下所示：\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const app = express(); // 用户已存在 const users = [{ email: \"abc@foo.com\" }]; app.use(bodyParser.json()); app.post(\"/users\", (req, res) =\u003e { const { email } = req.body; const userExists = users.find((u) =\u003e u.email === email); if (userExists) { return res.status(400).json({ error: \"User already exists\" }); } res.json(req.body); }); app.listen(3000, () =\u003e console.log(\"server started\")); 在上面的代码中，我们在 user 数组中有一个现有用户列表，包含了给定的电子邮件。\n那么如果我们尝试用已经存在于 users 中的 email 值来提交 payload，我们会得到一个 400 响应状态码，并附上 'User already exists' 的信息，让用户知道该用户已经存在。有了这些信息，用户可以将邮件改成数据库中尚不存在的邮件来纠正操作。\n错误代码需要有信息伴随，这样维护者就有足够的信息来解决问题，但攻击者不能利用错误内容来进行我们的攻击，比如窃取信息或使系统瘫痪。\n每当我们的 API 没有成功完成时，我们应该优雅地失败，发送一个带有信息的错误，以帮助用户做出纠正措施。\n支持过滤、排序和分页 REST API 背后的数据库可能变得非常庞大。有时候，数据太多，不应该一次全部返回，因为太慢了，或者会让我们的系统崩溃。因此，我们需要有办法来过滤项目。\n我们还需要对数据进行分页的方法，这样我们就能一次只返回几个结果。我们不希望因为一个请求，而占用资源太长时间。\n过滤和分页都可以通过减少服务器资源的使用来提高性能。随着数据库中积累的数据越多，这些功能就越发重要。\n这里有一个小例子，API 可以接受一个带有各种查询参数的查询字符串，让我们通过字段过滤出项目：\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const app = express(); // 数据库中的 employees 数据 const employees = [ { firstName: \"Jane\", lastName: \"Smith\", age: 20 }, //... { firstName: \"John\", lastName: \"Smith\", age: 30 }, { firstName: \"Mary\", lastName: \"Green\", age: 50 }, ]; app.use(bodyParser.json()); app.get(\"/employees\", (req, res) =\u003e { const { firstName, lastName, age } = req.query; let results = [...employees]; if (firstName) { results = results.filter((r) =\u003e r.firstName === firstName); } if (lastName) { results = results.filter((r) =\u003e r.lastName === lastName); } if (age) { results = results.filter((r) =\u003e +r.age === +age); } res.json(results); }); app.listen(3000, () =\u003e console.log(\"server started\")); 在上面的代码中，我们通过 req.query 变量来获取查询参数。然后，我们通过使用 JavaScript 解构语法将各个查询参数解构为变量，以提取属性值。最后，我们用每个查询参数值运行 filter 来定位我们想要返回的项目。\n一旦我们完成了这些工作，我们就将 results 作为响应返回。因此，当我们用查询字符串向以下路径发出 GET 请求时\n/employees?lastName=Smith\u0026age=30 我们得到\n[ { \"firstName\": \"John\", \"lastName\": \"Smith\", \"age\": 30 } ] 作为返回的响应，因为我们是按 lastName 和 age 过滤的。\n同样，我们也可以接受 page 查询参数，并返回一组从 (page - 1) * 20 到 page * 20 位置的条目。\n我们还可以在查询字符串中指定要排序的字段。例如，我们可以从查询字符串中获取参数，其中包含我们要对数据进行排序的字段。然后，我们可以按照这些单独的字段进行排序。\n例如，我们可能想从一个 URL 中提取查询字符串，比如。\nhttp://example.com/articles?sort=+author,-datepublished 其中 + 表示升序，- 表示降序。因此，我们按照作者姓名的字母顺序和 datepublished 从最新的到最旧的排序。\n保持良好的安全实践 客户端和服务器之间的大部分通信应该是私密的，因为我们经常发送和接收私人信息。因此，使用 SSL/TLS 来保证安全是必须的。\nSSL 证书加载到服务器上并不难，而且其是免费或花费很少的。我们应使我们的 REST API 通过安全通道，而不是在公开地通信。\n人们不应该能够访问到他们所请求的信息之外的信息。例如，一个普通用户不应该能够访问另一个用户的信息。他们也不应该能够访问管理员的数据。\n为了执行最小权限原则，我们需要添加角色检查，或者针对单一角色，或者为每个用户设置更细的角色。\n如果我们选择把用户分成几个角色群，那么这些角色的权限应该覆盖他们所需要的所有权限，而不是更多。如果我们对每个用户可以访问的功能有更细化的权限，那么我们要确保管理员可以相应地添加和删除每个用户的这些功能。另外，我们还需要添加一些预设的角色，可以应用于一组用户，这样我们就不必对每个用户都手动操作了。\n缓存数据以提高性能 我们可以添加缓存，从本地内存缓存中返回数据，而不是每次要检索用户请求的一些数据时，都要查询数据库。缓存的好处是，用户可以更快的获得数据。但是，用户得到的数据可能是过时的。这也可能导致在生产环境中调试时出现问题，因为我们一直看到旧的数据。\n缓存解决方案有很多种，比如 Redis、内存缓存等等。我们可以随着需求的变化，改变数据的缓存方式。\n例如，Express 有 apicache 中间件，不需要太多的配置就可以为我们的应用添加缓存功能。我们可以像这样在服务器中添加一个简单的内存缓存。\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const apicache = require(\"apicache\"); const app = express(); let cache = apicache.middleware; app.use(cache(\"5 minutes\")); // 数据库中的 employees 数据 const employees = [ { firstName: \"Jane\", lastName: \"Smith\", age: 20 }, //... { firstName: \"John\", lastName: \"Smith\", age: 30 }, { firstName: \"Mary\", lastName: \"Green\", age: 50 }, ]; app.use(bodyParser.json()); app.get(\"/employees\", (req, res) =\u003e { res.json(employees); }); app.listen(3000, () =\u003e console.log(\"server started\")); 上面的代码只是用 apicache.middleware 来引用 apicache 中间件，然后我们用:\napp.use(cache(\"5 minutes\")); 来将缓存应用于整个应用。比如说，我们将结果缓存 5 分钟。我们可以根据自己的需要调整。\n版本化我们的 API 如果我们要对 API 进行任何可能破坏客户端的修改，我们便应有不同的版本。版本划分可以像现在大多数应用一样，根据语义版本进行（例如，2.0.6 表示主要版本 2 和第 6 个补丁）。\n这样一来，我们可以逐步淘汰旧的端点，而不是强迫大家同时转移到新的 API 上。v1 端点可以为那些不想改变的人保持活跃，而 v2 则可以凭借其闪亮的新功能为那些准备升级的人服务。如果我们的 API 是公开的，这一点尤其重要。我们应该对它们进行版本调整，这样就不会破坏使用我们 API 的第三方应用。\n版本化通常是在 API 路径的开头加上 /v1/、/v2/ 等。\n例如，我们可以对 Express 进行如下操作。\nconst express = require(\"express\"); const bodyParser = require(\"body-parser\"); const app = express(); app.use(bodyParser.json()); app.get(\"/v1/employees\", (req, res) =\u003e { const employees = []; // 获取 employees 的代码 res.json(employees); }); app.get(\"/v2/employees\", (req, res) =\u003e { const employees = []; // 另一些获取 employees 的代码 res.json(employees); }); app.listen(3000, () =\u003e console.log(\"server started\")); 我们只需将版本号添加到端点 URL 路径的开头，就可以对它们进行版本控制。\n结束语 设计高质量的 REST API 最重要的思考是，通过遵循 Web 标准和约定来获取一致性。JSON、SSL/TLS 和 HTTP 状态码都是现代网络的标准构件。\n性能也是一个重要的考虑因素。我们可以通过不一次性返回太多数据来提高它的性能。此外，我们还可以使用缓存，这样我们就不必一直查询数据。\n端点的路径应该是一致的，我们只使用名词，因为 HTTP 方法表示我们要采取的行动。嵌套资源的路径应该在父资源的路径之后。它们应该告诉我们，我们正在获取或操作什么，而非我们需要阅读额外的文档来理解它在做什么。\n","wordCount":"5205","inLanguage":"zh","datePublished":"2021-03-18T18:51:25+08:00","dateModified":"2021-03-18T18:51:25+08:00","author":{"@type":"Person","name":"Jinglue"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.batkiz.com/posts/best-practices-for-rest-api-design/"},"publisher":{"@type":"Organization","name":"not b@tk1z","logo":{"@type":"ImageObject","url":"https://blog.batkiz.com/favicon.ico"}}}</script><link rel=icon href=/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/favicon.ico><link rel=manifest href=/favicon.ico><link rel=preconnect href=https://fonts.loli.net><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.loli.net/css2?family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.loli.net/css2?family=Noto+Serif+SC&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.loli.net/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Noto+Serif+SC&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link rel=stylesheet href=/css/main.min.28245603abfbc0a0a9ef30287c2872f82f0e6075e5b630bff570c8480b95b904.css integrity="sha256-KCRWA6v7wKCp7zAofChy+C8OYHXltjC/9XDISAuVuQQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>not b@tk1z
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/posts>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/links>链接</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/atom.xml>RSS</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/about>关于</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/batkiz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-social"><a class=navigation-link href=mailto:batkiz@outlook.com><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" class="main-grid-item-icon" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>翻译|REST API 设计最佳实践</h1></header><p><small>2021年3月18日&nbsp;· 5205 字&nbsp;· 11 分钟</small>
<small>·
<a href=https://blog.batkiz.com/tags/%E7%BF%BB%E8%AF%91/>翻译</a>
<a href=https://blog.batkiz.com/tags/stackoverflow/>Stackoverflow</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#用-json-接收与响应>用 JSON 接收与响应</a></li><li><a href=#在端点路径中使用名词而非动词>在端点路径中使用名词而非动词</a></li><li><a href=#使用名词复数来命名集合>使用名词复数来命名集合</a></li><li><a href=#分层对象的资源嵌套>分层对象的资源嵌套</a></li><li><a href=#优雅地处理错误并返回标准的错误代码>优雅地处理错误并返回标准的错误代码</a></li><li><a href=#支持过滤排序和分页>支持过滤、排序和分页</a></li><li><a href=#保持良好的安全实践>保持良好的安全实践</a></li><li><a href=#缓存数据以提高性能>缓存数据以提高性能</a></li><li><a href=#版本化我们的-api>版本化我们的 API</a></li><li><a href=#结束语>结束语</a></li></ul></nav></div><section class=blog-content><p>原文链接：<a href=https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/>Best practices for REST API design</a></p><p>译者按：关于 REST API 的介绍与最佳实践，亦可参见微软 <a href=https://docs.microsoft.com/zh-cn/azure/architecture/best-practices/api-design>Web API 设计</a>。</p><p>声明：本文的完成亦有 <a href=https://www.deepl.com/>DeepL</a> 的帮助。</p><hr><p>REST API 是现今最常见的网络服务之一。它允许包括浏览器在内的多种客户端通过 REST API 与服务器进行通信。</p><p>因此，正确地设计 REST API 非常重要，这样我们就不会在后续的道路上出现问题。我们必须考虑到 API 用户的账号安全性、性能和易用性。</p><p>否则，我们就会给使用我们 API 的客户们带来问题，这并不令人愉快，也会影响人们使用我们的 API。如果我们不遵循普遍接受的惯例，那么我们就会给 API 的维护者和使用它们的客户带来困扰，因为它与大家所期望的不同。</p><p>在这篇文章中，我们将探讨如何设计 REST API，使其对任何使用它们的人来说都是容易理解的，是不会过时的，并且是安全和快速的，因为它们向客户提供的数据可能是保密的。</p><p>由于网络应用可能会被多种问题破坏，我们应该确保任何 REST API 都应使用标准的 HTTP 状态码，以优雅地处理错误，帮助用户处理问题。</p><h2 id=用-json-接收与响应>用 JSON 接收与响应</h2><p>REST API 应该接收 JSON 作为请求的有效载荷（payload），同时也应以 JSON 发送响应。JSON 是传输数据的标准。几乎所有的网络技术都可以使用它：JavaScript 有内置的方法，可以通过 Fetch API 或其他 HTTP 客户端对 JSON 进行编码和解码。服务器端的技术也有一些库可以解码 JSON，不需要做太多工作。</p><p>当然，还有其他传输数据的方式。XML 并没有得到框架的广泛支持，其常用替代通常是 JSON。我们在客户端——尤其是在浏览器中——不能特别容易地操作这些数据。光是做正常的数据传输就会有很多额外的工作。</p><p>表单数据（form data）很适合用于发送数据，特别是当我们要发送文件时。但是对于文本和数字，我们不需要表单数据来传输这些，因为——对大多数框架来说——我们只需要在客户端直接从中获取数据就可以传输 JSON。这是到目前为止最直接的做法。</p><p>为了确保当我们的 REST API 应用以 JSON 响应时，客户端会将其解释为 JSON，我们应该在请求发出后，将响应头（header）中的 <code>Content-Type</code> 设置为 <code>application/json</code>。很多服务器端应用框架都会自动设置响应头。一些 HTTP 客户端会根据 <code>Content-Type</code> 响应头来解析数据。</p><p>唯一的例外是，如果我们试图在客户端和服务器之间发送和接收文件。那么我们就需要处理文件响应，从客户端向服务器发送表单数据。但这就是另外一个话题了。</p><p>我们还应该确保我们的端点（endpoint）能够返回 JSON 作为响应。许多服务器端框架都将此作为一个内置功能。</p><p>让我们来看看一个接受 JSON payload 的 API 示例。这个例子将使用 Node.js 的 <a href=https://expressjs.com/>Express</a> 后端框架。我们可以使用 <a href=https://www.npmjs.com/package/body-parser><code>body-parser</code> 中间件</a> 来解析 JSON 请求体，然后我们可以调用 <code>res.json</code> 方法，将我们想要返回的对象构造为 JSON 响应，如下所示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>post</span>(<span style=color:#e6db74>&#34;/&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>body</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p><code>bodyParser.json()</code> 将 JSON 请求体字符串解析为 JavaScript 对象，然后将其分配给 <code>req.body</code> 对象。</p><p>将响应中的 <code>Content-Type</code> 头设置为 <code>application/json; charset=utf-8</code>，不要做任何修改。这个方法适用于大多数其他后端框架。</p><h2 id=在端点路径中使用名词而非动词>在端点路径中使用名词而非动词</h2><p>我们不应该在端点路径中使用动词。相反，我们应该使用名词作为路径名，该名词应代表我们要检索或操作的端点的实体。</p><p>这是因为我们的 HTTP 请求方法已经在用动词了。在我们的 API 端点路径中使用动词并没有益处，而且会使它变得不必要的长，因为它没有传达任何新的信息。选择的动词可以根据开发者的想法而变化。比如说，有些人喜欢用 &ldquo;get&rdquo;，有些人喜欢用 &ldquo;retrieve&rdquo;，所以让 HTTP GET 动词告诉我们什么和端点做什么就好了。</p><p>动作应该由我们所做的 HTTP 请求方法来表示。最常见的方法包括 GET、POST、PUT 和 DELETE。</p><p>GET 检索资源。POST 向服务器提交新数据。PUT 更新现有数据。DELETE 删除数据。这些动词映射到 <a href=https://en.wikipedia.org/wiki/Create,_read,_update_and_delete>CRUD</a> 操作。</p><p>考虑到我们上面讨论的两个原则，我们应该创建像 GET <code>/articles/</code> 这样的路由来获取新闻文章。同样，POST <code>/articles/</code> 用于添加新的文章，PUT <code>/articles/:id</code> 用于用给定的 id 更新文章。DELETE <code>/articles/:id</code> 用于删除给定 ID 的现有文章。</p><p><code>/articles</code> 代表一个 REST API 资源。例如，我们可以使用 Express 添加以下端点来操作文章，如下所示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/articles&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>articles</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取文章的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>articles</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>post</span>(<span style=color:#e6db74>&#34;/articles&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 添加新文章的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>body</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/articles/:id&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>id</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>params</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 更新文章的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>body</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#e6db74>&#34;/articles/:id&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>id</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>params</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 删除文章的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>({ <span style=color:#a6e22e>deleted</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>id</span> });
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p>在上面的代码中，我们定义了操作文章的端点。我们可以看到，路径名中没有任何动词。所有的都是名词。动词在 HTTP 动词中。</p><p>POST、PUT 和 DELETE 端点都以 JSON 作为请求体，也都以 JSON 作为响应返回，包括 GET 端点。</p><h2 id=使用名词复数来命名集合>使用名词复数来命名集合</h2><p>我们应该用名词复数来命名集合。我们通常不会只想得到一个单项，所以我们的命名应该是一致的，我们应该用名词复数。</p><p>我们使用名词复数是为了和我们数据库中的内容保持一致。表通常有多个条目，并且在命名时会反映这一点，所以为了与它们保持一致，我们应该使用与 API 访问的表相同的语言。</p><p>对于 <code>/articles</code> 端点，我们的所有端点都是复数形式，所以我们不必将其改为复数。（译者注：此处似乎指的是上面代码之中的端点）</p><h2 id=分层对象的资源嵌套>分层对象的资源嵌套</h2><p>在处理嵌套资源的端点的路径时，应把嵌套资源追加为父资源后面的路径上。</p><p>我们必须确保我们考虑的嵌套资源与我们数据库表中的资源相匹配。否则会非常混乱。</p><p>比如说，如果我们想要一个端点来获取一篇新闻文章的评论，我们应该将 <code>/comments</code> 追加到 <code>/articles</code> 路径的末尾。这假设了我们在数据库中把评论（<code>comments</code>）作为文章（<code>articles</code>）的一个子节点。</p><p>例如，我们可以在 Express 中使用以下代码来实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/articles/:articleId/comments&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>articleId</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>params</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>comments</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 通过 articleId 获取评论的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>comments</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p>在上面的代码中，我们可以在路径 <code>'/articles/:articleId/comments'</code> 上使用 GET 方法。我们获取由 <code>articleId</code> 标识的文章的评论，然后在响应中返回。我们在 <code>'/articles/:articleId'</code> 路径后添加 <code>'comments'</code>，以表明它是 <code>/articles</code> 的子资源。</p><p>这是有意义的，因为评论（<code>comments</code>）是文章的子对象，假设每篇文章都有自己的评论。否则，就会让用户感到困惑，因为这个结构一般被认为是用来访问子对象的。同样的原理也适用于 POST、PUT 和 DELETE 端点。它们的路径名都可以使用同一种嵌套结构。</p><h2 id=优雅地处理错误并返回标准的错误代码>优雅地处理错误并返回标准的错误代码</h2><p>为了消除 API 用户在发生错误时的困惑，我们应该优雅地处理错误，并返回 HTTP 响应代码，说明发生了什么样的错误。这样可以让 API 的维护者有足够的信息来了解发生的问题。我们不希望错误使我们的系统崩溃，所以我们可以不处理它们，这意味着 API 消费者必须处理它们。</p><p>常见的错误 HTTP 状态码包括：</p><ul><li>400 Bad Request - 这意味着客户端的输入没有通过验证。</li><li>401 Unauthorized - 这意味着用户没有被授权访问资源。它通常在用户未认证时返回。</li><li>403 Forbidden - 这表示用户已通过认证，但不允许访问资源。</li><li>404 Not Found - 这表示找不到资源。</li><li>500 Internal server error - 这是一个通用的服务器错误。它可能不应该被明确地抛出。</li><li>502 <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502>Bad Gateway</a> - 这表示上游服务器发来了无效响应。</li><li>503 Service Unavailable - 这表示在服务器端发生了一些意想不到的事情（可能是任何事情，比如服务器过载，系统的某些部分失效，等等）。</li></ul><p>我们抛出的错误应该与我们的应用所遇到的问题相对应。例如，如果我们想拒绝请求 payload 中的数据，那么我们应该在 Express API 中返回一个 400 响应，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 用户已存在
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>users</span> <span style=color:#f92672>=</span> [{ <span style=color:#a6e22e>email</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;abc@foo.com&#34;</span> }];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>post</span>(<span style=color:#e6db74>&#34;/users&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>email</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>body</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>userExists</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>users</span>.<span style=color:#a6e22e>find</span>((<span style=color:#a6e22e>u</span>) =&gt; <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>email</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>email</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>userExists</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>status</span>(<span style=color:#ae81ff>400</span>).<span style=color:#a6e22e>json</span>({ <span style=color:#a6e22e>error</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;User already exists&#34;</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>body</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p>在上面的代码中，我们在 <code>user</code> 数组中有一个现有用户列表，包含了给定的电子邮件。</p><p>那么如果我们尝试用已经存在于 <code>users</code> 中的 <code>email</code> 值来提交 payload，我们会得到一个 400 响应状态码，并附上 <code>'User already exists'</code> 的信息，让用户知道该用户已经存在。有了这些信息，用户可以将邮件改成数据库中尚不存在的邮件来纠正操作。</p><p>错误代码需要有信息伴随，这样维护者就有足够的信息来解决问题，但攻击者不能利用错误内容来进行我们的攻击，比如窃取信息或使系统瘫痪。</p><p>每当我们的 API 没有成功完成时，我们应该优雅地失败，发送一个带有信息的错误，以帮助用户做出纠正措施。</p><h2 id=支持过滤排序和分页>支持过滤、排序和分页</h2><p>REST API 背后的数据库可能变得非常庞大。有时候，数据太多，不应该一次全部返回，因为太慢了，或者会让我们的系统崩溃。因此，我们需要有办法来过滤项目。</p><p>我们还需要对数据进行分页的方法，这样我们就能一次只返回几个结果。我们不希望因为一个请求，而占用资源太长时间。</p><p>过滤和分页都可以通过减少服务器资源的使用来提高性能。随着数据库中积累的数据越多，这些功能就越发重要。</p><p>这里有一个小例子，API 可以接受一个带有各种查询参数的查询字符串，让我们通过字段过滤出项目：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 数据库中的 employees 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>employees</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Jane&#34;</span>, <span style=color:#a6e22e>lastName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Smith&#34;</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>20</span> },
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  { <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#a6e22e>lastName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Smith&#34;</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>30</span> },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Mary&#34;</span>, <span style=color:#a6e22e>lastName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Green&#34;</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>50</span> },
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/employees&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>firstName</span>, <span style=color:#a6e22e>lastName</span>, <span style=color:#a6e22e>age</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>query</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>results</span> <span style=color:#f92672>=</span> [...<span style=color:#a6e22e>employees</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>firstName</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>results</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>results</span>.<span style=color:#a6e22e>filter</span>((<span style=color:#a6e22e>r</span>) =&gt; <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>firstName</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>firstName</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>lastName</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>results</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>results</span>.<span style=color:#a6e22e>filter</span>((<span style=color:#a6e22e>r</span>) =&gt; <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>lastName</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>lastName</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>age</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>results</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>results</span>.<span style=color:#a6e22e>filter</span>((<span style=color:#a6e22e>r</span>) =&gt; <span style=color:#f92672>+</span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>===</span> <span style=color:#f92672>+</span><span style=color:#a6e22e>age</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>results</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p>在上面的代码中，我们通过 <code>req.query</code> 变量来获取查询参数。然后，我们通过使用 JavaScript 解构语法将各个查询参数解构为变量，以提取属性值。最后，我们用每个查询参数值运行 <code>filter</code> 来定位我们想要返回的项目。</p><p>一旦我们完成了这些工作，我们就将 <code>results</code> 作为响应返回。因此，当我们用查询字符串向以下路径发出 GET 请求时</p><pre tabindex=0><code>/employees?lastName=Smith&amp;age=30
</code></pre><p>我们得到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;firstName&#34;</span>: <span style=color:#e6db74>&#34;John&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;lastName&#34;</span>: <span style=color:#e6db74>&#34;Smith&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;age&#34;</span>: <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>作为返回的响应，因为我们是按 <code>lastName</code> 和 <code>age</code> 过滤的。</p><p>同样，我们也可以接受 <code>page</code> 查询参数，并返回一组从 <code>(page - 1) * 20</code> 到 <code>page * 20</code> 位置的条目。</p><p>我们还可以在查询字符串中指定要排序的字段。例如，我们可以从查询字符串中获取参数，其中包含我们要对数据进行排序的字段。然后，我们可以按照这些单独的字段进行排序。</p><p>例如，我们可能想从一个 URL 中提取查询字符串，比如。</p><pre tabindex=0><code>http://example.com/articles?sort=+author,-datepublished
</code></pre><p>其中 <code>+</code> 表示升序，<code>-</code> 表示降序。因此，我们按照作者姓名的字母顺序和 <code>datepublished</code> 从最新的到最旧的排序。</p><h2 id=保持良好的安全实践>保持良好的安全实践</h2><p>客户端和服务器之间的大部分通信应该是私密的，因为我们经常发送和接收私人信息。因此，使用 SSL/TLS 来保证安全是必须的。</p><p>SSL 证书加载到服务器上并不难，而且其是免费或花费很少的。我们应使我们的 REST API 通过安全通道，而不是在公开地通信。</p><p>人们不应该能够访问到他们所请求的信息之外的信息。例如，一个普通用户不应该能够访问另一个用户的信息。他们也不应该能够访问管理员的数据。</p><p>为了执行最小权限原则，我们需要添加角色检查，或者针对单一角色，或者为每个用户设置更细的角色。</p><p>如果我们选择把用户分成几个角色群，那么这些角色的权限应该覆盖他们所需要的所有权限，而不是更多。如果我们对每个用户可以访问的功能有更细化的权限，那么我们要确保管理员可以相应地添加和删除每个用户的这些功能。另外，我们还需要添加一些预设的角色，可以应用于一组用户，这样我们就不必对每个用户都手动操作了。</p><h2 id=缓存数据以提高性能>缓存数据以提高性能</h2><p>我们可以添加缓存，从本地内存缓存中返回数据，而不是每次要检索用户请求的一些数据时，都要查询数据库。缓存的好处是，用户可以更快的获得数据。但是，用户得到的数据可能是过时的。这也可能导致在生产环境中调试时出现问题，因为我们一直看到旧的数据。</p><p>缓存解决方案有很多种，比如 <a href=https://redis.io/>Redis</a>、内存缓存等等。我们可以随着需求的变化，改变数据的缓存方式。</p><p>例如，Express 有 <a href=https://www.npmjs.com/package/apicache>apicache</a> 中间件，不需要太多的配置就可以为我们的应用添加缓存功能。我们可以像这样在服务器中添加一个简单的内存缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>apicache</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;apicache&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cache</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>apicache</span>.<span style=color:#a6e22e>middleware</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>cache</span>(<span style=color:#e6db74>&#34;5 minutes&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 数据库中的 employees 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>employees</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Jane&#34;</span>, <span style=color:#a6e22e>lastName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Smith&#34;</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>20</span> },
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  { <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#a6e22e>lastName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Smith&#34;</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>30</span> },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Mary&#34;</span>, <span style=color:#a6e22e>lastName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Green&#34;</span>, <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>50</span> },
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/employees&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>employees</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p>上面的代码只是用 <code>apicache.middleware</code> 来引用 <code>apicache</code> 中间件，然后我们用:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>cache</span>(<span style=color:#e6db74>&#34;5 minutes&#34;</span>));
</span></span></code></pre></div><p>来将缓存应用于整个应用。比如说，我们将结果缓存 5 分钟。我们可以根据自己的需要调整。</p><h2 id=版本化我们的-api>版本化我们的 API</h2><p>如果我们要对 API 进行任何可能破坏客户端的修改，我们便应有不同的版本。版本划分可以像现在大多数应用一样，根据语义版本进行（例如，2.0.6 表示主要版本 2 和第 6 个补丁）。</p><p>这样一来，我们可以逐步淘汰旧的端点，而不是强迫大家同时转移到新的 API 上。v1 端点可以为那些不想改变的人保持活跃，而 v2 则可以凭借其闪亮的新功能为那些准备升级的人服务。如果我们的 API 是公开的，这一点尤其重要。我们应该对它们进行版本调整，这样就不会破坏使用我们 API 的第三方应用。</p><p>版本化通常是在 API 路径的开头加上 <code>/v1/</code>、<code>/v2/</code> 等。</p><p>例如，我们可以对 Express 进行如下操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>express</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;express&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bodyParser</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;body-parser&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>bodyParser</span>.<span style=color:#a6e22e>json</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/v1/employees&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>employees</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取 employees 的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>employees</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/v2/employees&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>employees</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 另一些获取 employees 的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>(<span style=color:#a6e22e>employees</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;server started&#34;</span>));
</span></span></code></pre></div><p>我们只需将版本号添加到端点 URL 路径的开头，就可以对它们进行版本控制。</p><h2 id=结束语>结束语</h2><p>设计高质量的 REST API 最重要的思考是，通过遵循 Web 标准和约定来获取一致性。JSON、SSL/TLS 和 HTTP 状态码都是现代网络的标准构件。</p><p>性能也是一个重要的考虑因素。我们可以通过不一次性返回太多数据来提高它的性能。此外，我们还可以使用缓存，这样我们就不必一直查询数据。</p><p>端点的路径应该是一致的，我们只使用名词，因为 HTTP 方法表示我们要采取的行动。嵌套资源的路径应该在父资源的路径之后。它们应该告诉我们，我们正在获取或操作什么，而非我们需要阅读额外的文档来理解它在做什么。</p></section><div class=paginator><a class=prev href=https://blog.batkiz.com/posts/bye-2021/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Bye 2021</span></a>
<a class=next href=https://blog.batkiz.com/posts/theme-new-feat-repl-embed/><span>博客主题新功能：repl 代码集成</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.batkiz.com/>not b@tk1z</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "fd2a175921e640c8a40b873fb5e58aaa"}'></script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>