<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Conway's Game of Life</title>
<meta charset=utf-8><meta name=description content="Ladder@R.I.P John Conway. 由于近期席卷全球的新冠肺炎，John Conway 不幸染病离世。生命游戏 (Game of Life) 是其最为著名的成果。几天前我在 Codewars 上刷到了相关的题目，花了一段时间做了"><meta name=author content="Jinglue"><link rel=canonical href=https://blog.batkiz.com/posts/conways-game-of-life/><link rel=alternate type=application/rss+xml href=https://blog.batkiz.com//index.xml title="not b@tk1z"><meta property="og:title" content="Conway's Game of Life"><meta property="og:description" content="R.I.P John Conway. 由于近期席卷全球的新冠肺炎，John Conway 不幸染病离世。生命游戏 (Game of Life) 是其最为著名的成果。几天前我在 Codewars 上刷到了相关的题目，花了一段时间做了"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.batkiz.com/posts/conways-game-of-life/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-17T20:55:58+08:00"><meta property="article:modified_time" content="2020-04-17T20:55:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Conway's Game of Life"><meta name=twitter:description content="R.I.P John Conway. 由于近期席卷全球的新冠肺炎，John Conway 不幸染病离世。生命游戏 (Game of Life) 是其最为著名的成果。几天前我在 Codewars 上刷到了相关的题目，花了一段时间做了"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Conway's Game of Life","item":"https://blog.batkiz.com/posts/conways-game-of-life/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Conway's Game of Life","name":"Conway\u0027s Game of Life","description":"R.I.P John Conway. 由于近期席卷全球的新冠肺炎，John Conway 不幸染病离世。生命游戏 (Game of Life) 是其最为著名的成果。几天前我在 Codewars 上刷到了相关的题目，花了一段时间做了","keywords":["codewars","csharp"],"articleBody":"R.I.P John Conway.\n由于近期席卷全球的新冠肺炎，John Conway 不幸染病离世。生命游戏 (Game of Life) 是其最为著名的成果。几天前我在 Codewars 上刷到了相关的题目，花了一段时间做了出来，在此写一篇文章，就当是为了纪念 Conway 吧。\n题目 Given a 2D array and a number of generations, compute n timesteps of Conway’s Game of Life.\nThe rules of the game are:\nAny live cell with fewer than two live neighbours dies, as if caused by underpopulation. Any live cell with more than three live neighbours dies, as if by overcrowding. Any live cell with two or three live neighbours lives on to the next generation. Any dead cell with exactly three live neighbours becomes a live cell. Each cell’s neighborhood is the 8 cells immediately around it (i.e. Moore Neighborhood). The universe is infinite in both the x and y dimensions and all cells are initially dead - except for those specified in the arguments. The return value should be a 2d array cropped around all of the living cells. (If there are no living cells, then return [[]].)\n题目其实就是生命游戏的定义：\n在一个无限大的棋盘上，我们以 1 代表存活的生命，以 0 代表死去的生命或 无。\n其上的生命遵循上面的四条规则存活、死去、或是产生下一代。\n思路 public static int[,] GetGeneration(int[,] cells, int generation) 可以看到函数接收了二维数组与一个整数，分别代表了其上的生命与要演化的代数。\n首先我们要认识清楚，棋盘的大小是无限的，而不仅仅是接收的二维数组的大小。当然，题中也给出了计算邻居的规则，我们在处理时，要将接收到的数组扩大一圈。\n新建一个长宽各自 +2 的矩形，再把目前的矩形放在其正中间，最后返回这个矩形。\npublic static int[,] NewBoard(int[,] cells) { var hang = cells.GetLength(0); var lie = cells.GetLength(1); var newBoard = new int[hang + 2, lie + 2]; for (int i = 0; i \u003c hang + 2; i++) { for (int j = 0; j \u003c lie + 2; j++) { newBoard[i, j] = 0; } } for (int i = 1; i \u003c hang + 1; i++) { for (int j = 1; j \u003c lie + 1; j++) { newBoard[i, j] = cells[i - 1, j - 1]; } } return newBoard; } 相应的，在返回最终的结果时，棋盘除了有生命存在的一个矩形之外，也要裁剪掉多出的全为 0 的行与列。\n这里是分别从上下、左右遍历了数组，获取了其存在 1 的最外层的坐标，然后把它裁剪了下来，返回了最精简的数组。\npublic static int[,] cropped(int[,] cells) { var hang = cells.GetLength(0); var lie = cells.GetLength(1); var (hStart, lStart, hEnd, lEnd, hLen, lLen) = (0, 0, 0, 0, 0, 0); for (int i = 0; i \u003c hang; i++) { for (int j = 0; j \u003c lie; j++) { if (cells[i, j] != 0) { hStart = i; i = hang; break; } } } for (int i = hang - 1; i \u003e= 0; i--) { for (int j = lie - 1; j \u003e= 0; j--) { if (cells[i, j] != 0) { hEnd = i; i = 0; break; } } } for (int i = 0; i \u003c lie; i++) { for (int j = 0; j \u003c hang; j++) { if (cells[j, i] != 0) { lStart = i; i = lie; break; } } } for (int i = lie - 1; i \u003e= 0; i--) { for (int j = hang - 1; j \u003e= 0; j--) { if (cells[j, i] != 0) { lEnd = i; i = 0; break; } } } hLen = hEnd - hStart + 1; lLen = lEnd - lStart + 1; var newCell = new int[hLen, lLen]; for (int i = 0; i \u003c hLen; i++) { for (int j = 0; j \u003c lLen; j++) { newCell[i, j] = cells[hStart + i, lStart + j]; } } return newCell; } 确定了最先与最后的步骤，就要处理中间的过程了。\n为了确定某一个坐标下的生物在下一轮中是死是活，只需要获取它有多少存活的邻居，再用给出的四条规则来判定就能得出了。\n首先是获取某一特定坐标的生物有多少活着的邻居，仅需遍历它八个邻居的位置并确定是否存活即可。值得注意的是，对于最外层、邻居不足八个的生物要做特殊的处理，以防数组越界。由于我懒得确定是否越界，就用了一个邪道玩法，如果出现了数组越界的 Exception 就忽略掉它继续访问下一个地址。\npublic static int GetLiveNeighbors(int x, int y, int[,] ceil) { var val = 0; int[] neighbors = { 0, 1, -1 }; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 3; j++) { if (!(neighbors[i] == 0 \u0026\u0026 neighbors[j] == 0)) { int r = (x + neighbors[i]); int c = (y + neighbors[j]); try { if (ceil[r, c] == 1) { val += 1; } } catch (System.Exception) { val += 0; continue; } } } } return val; } 下面则是确定某一坐标下的生物在下一轮中是死是活。\nvar hang = cells.GetLength(0); var lie = cells.GetLength(1); var newGen = new int[hang + 2, lie + 2]; var biggerCells = NewBoard(cells); for (int x = 0; x \u003c hang + 2; x++) { for (int y = 0; y \u003c lie + 2; y++) { var n = GetLiveNeighbors(x, y, biggerCells); var c = biggerCells[x, y]; newGen[x, y] = ((c == 1) \u0026\u0026 (n == 2 || n == 3) || (c == 0) \u0026\u0026 n == 3) ? 1 : 0; } } var result = cropped(newGen); 至于代数，一个递归就能解决问题了。在此不作赘述。\n完整代码 using System; using System.Linq; public class ConwayLife { public static int[,] GetGeneration(int[,] cells, int generation) { if (generation \u003c= 0) { return cells; } var hang = cells.GetLength(0); var lie = cells.GetLength(1); var newGen = new int[hang + 2, lie + 2]; var biggerCells = NewBoard(cells); for (int x = 0; x \u003c hang + 2; x++) { for (int y = 0; y \u003c lie + 2; y++) { var n = GetLiveNeighbors(x, y, biggerCells); var c = biggerCells[x, y]; newGen[x, y] = ((c == 1) \u0026\u0026 (n == 2 || n == 3) || (c == 0) \u0026\u0026 n == 3) ? 1 : 0; } } var result = cropped(newGen); return GetGeneration(result, generation - 1); } public static int GetLiveNeighbors(int x, int y, int[,] ceil) { var val = 0; int[] neighbors = { 0, 1, -1 }; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 3; j++) { if (!(neighbors[i] == 0 \u0026\u0026 neighbors[j] == 0)) { int r = (x + neighbors[i]); int c = (y + neighbors[j]); try { if (ceil[r, c] == 1) { val += 1; } } catch (System.Exception) { val += 0; continue; } } } } return val; } public static int[,] cropped(int[,] cells) { var hang = cells.GetLength(0); var lie = cells.GetLength(1); var (hStart, lStart, hEnd, lEnd, hLen, lLen) = (0, 0, 0, 0, 0, 0); for (int i = 0; i \u003c hang; i++) { for (int j = 0; j \u003c lie; j++) { if (cells[i, j] != 0) { hStart = i; i = hang; break; } } } for (int i = hang - 1; i \u003e= 0; i--) { for (int j = lie - 1; j \u003e= 0; j--) { if (cells[i, j] != 0) { hEnd = i; i = 0; break; } } } for (int i = 0; i \u003c lie; i++) { for (int j = 0; j \u003c hang; j++) { if (cells[j, i] != 0) { lStart = i; i = lie; break; } } } for (int i = lie - 1; i \u003e= 0; i--) { for (int j = hang - 1; j \u003e= 0; j--) { if (cells[j, i] != 0) { lEnd = i; i = 0; break; } } } hLen = hEnd - hStart + 1; lLen = lEnd - lStart + 1; var newCell = new int[hLen, lLen]; Console.WriteLine($\"h {hLen} l {lLen}\"); for (int i = 0; i \u003c hLen; i++) { for (int j = 0; j \u003c lLen; j++) { newCell[i, j] = cells[hStart + i, lStart + j]; } } return newCell; } public static int[,] NewBoard(int[,] cells) { var hang = cells.GetLength(0); var lie = cells.GetLength(1); var newBoard = new int[hang + 2, lie + 2]; for (int i = 0; i \u003c hang + 2; i++) { for (int j = 0; j \u003c lie + 2; j++) { newBoard[i, j] = 0; } } for (int i = 1; i \u003c hang + 1; i++) { for (int j = 1; j \u003c lie + 1; j++) { newBoard[i, j] = cells[i - 1, j - 1]; } } return newBoard; } } ","wordCount":"1871","inLanguage":"zh","datePublished":"2020-04-17T20:55:58+08:00","dateModified":"2020-04-17T20:55:58+08:00","author":{"@type":"Person","name":"Jinglue"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.batkiz.com/posts/conways-game-of-life/"},"publisher":{"@type":"Organization","name":"not b@tk1z","logo":{"@type":"ImageObject","url":"https://blog.batkiz.com/favicon.ico"}}}</script><link rel=icon href=/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/favicon.ico><link rel=manifest href=/favicon.ico><link rel=preconnect href=https://fonts.loli.net><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.loli.net/css2?family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.loli.net/css2?family=Noto+Serif+SC&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.loli.net/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Noto+Serif+SC&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link rel=stylesheet href=/css/main.min.28245603abfbc0a0a9ef30287c2872f82f0e6075e5b630bff570c8480b95b904.css integrity="sha256-KCRWA6v7wKCp7zAofChy+C8OYHXltjC/9XDISAuVuQQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>not b@tk1z
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/posts>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/links>链接</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/atom.xml>RSS</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/about>关于</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/batkiz><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-social"><a class=navigation-link href=mailto:batkiz@outlook.com><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" class="main-grid-item-icon" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Conway's Game of Life</h1></header><p><small>2020年4月17日&nbsp;· 1871 字&nbsp;· 4 分钟</small>
<small>·
<a href=https://blog.batkiz.com/tags/codewars/>Codewars</a>
<a href=https://blog.batkiz.com/tags/csharp/>Csharp</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#题目>题目</a></li><li><a href=#思路>思路</a></li><li><a href=#完整代码>完整代码</a></li></ul></nav></div><section class=blog-content><p>R.I.P John Conway.</p><p>由于近期席卷全球的新冠肺炎，John Conway 不幸染病离世。生命游戏 (Game of Life) 是其最为著名的成果。几天前我在 Codewars 上刷到了相关的题目，花了一段时间做了出来，在此写一篇文章，就当是为了纪念 Conway 吧。</p><h2 id=题目>题目</h2><p>Given a 2D array and a number of generations, compute n timesteps of <a href=http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>Conway&rsquo;s Game of Life</a>.</p><p>The rules of the game are:</p><ol><li>Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.</li><li>Any live cell with more than three live neighbours dies, as if by overcrowding.</li><li>Any live cell with two or three live neighbours lives on to the next generation.</li><li>Any dead cell with exactly three live neighbours becomes a live cell.</li></ol><p>Each cell&rsquo;s neighborhood is the 8 cells immediately around it (i.e. <a href=https://en.wikipedia.org/wiki/Moore_neighborhood>Moore Neighborhood</a>). The universe is infinite in both the x and y dimensions and all cells are initially dead - except for those specified in the arguments. The return value should be a 2d array cropped around all of the living cells. (If there are no living cells, then return <code>[[]]</code>.)</p><p>题目其实就是生命游戏的定义：</p><p>在一个无限大的棋盘上，我们以 <code>1</code> 代表存活的生命，以 <code>0</code> 代表死去的生命或 <code>无</code>。</p><p>其上的生命遵循上面的四条规则存活、死去、或是产生下一代。</p><h2 id=思路>思路</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>[,] GetGeneration(<span style=color:#66d9ef>int</span>[,] cells, <span style=color:#66d9ef>int</span> generation)
</span></span></code></pre></div><p>可以看到函数接收了二维数组与一个整数，分别代表了其上的生命与要演化的代数。</p><p>首先我们要认识清楚，棋盘的大小是<strong>无限的</strong>，而不仅仅是接收的二维数组的大小。当然，题中也给出了计算邻居的规则，我们在处理时，要将接收到的数组扩大一圈。</p><p>新建一个长宽各自 +2 的矩形，再把目前的矩形放在其正中间，最后返回这个矩形。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>[,] NewBoard(<span style=color:#66d9ef>int</span>[,] cells)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> hang = cells.GetLength(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> lie = cells.GetLength(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> newBoard = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[hang + <span style=color:#ae81ff>2</span>, lie + <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hang + <span style=color:#ae81ff>2</span>; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; lie + <span style=color:#ae81ff>2</span>; j++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newBoard[i, j] = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; hang + <span style=color:#ae81ff>1</span>; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>1</span>; j &lt; lie + <span style=color:#ae81ff>1</span>; j++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newBoard[i, j] = cells[i - <span style=color:#ae81ff>1</span>, j - <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newBoard;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>相应的，在返回最终的结果时，棋盘除了有生命存在的一个矩形之外，也要裁剪掉多出的全为 0 的行与列。</p><p>这里是分别从上下、左右遍历了数组，获取了其存在 1 的最外层的坐标，然后把它裁剪了下来，返回了最精简的数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>[,] cropped(<span style=color:#66d9ef>int</span>[,] cells)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> hang = cells.GetLength(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> lie = cells.GetLength(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> (hStart, lStart, hEnd, lEnd, hLen, lLen) = (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hang; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; lie; j++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cells[i, j] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                hStart = i;
</span></span><span style=display:flex><span>                i = hang;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = hang - <span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>0</span>; i--)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = lie - <span style=color:#ae81ff>1</span>; j &gt;= <span style=color:#ae81ff>0</span>; j--)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cells[i, j] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                hEnd = i;
</span></span><span style=display:flex><span>                i = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; lie; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; hang; j++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cells[j, i] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                lStart = i;
</span></span><span style=display:flex><span>                i = lie;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = lie - <span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>0</span>; i--)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = hang - <span style=color:#ae81ff>1</span>; j &gt;= <span style=color:#ae81ff>0</span>; j--)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cells[j, i] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                lEnd = i;
</span></span><span style=display:flex><span>                i = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hLen = hEnd - hStart + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    lLen = lEnd - lStart + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> newCell = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[hLen, lLen];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hLen; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; lLen; j++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newCell[i, j] = cells[hStart + i, lStart + j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newCell;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>确定了最先与最后的步骤，就要处理中间的过程了。</p><p>为了确定某一个坐标下的生物在下一轮中是死是活，只需要获取它有多少存活的邻居，再用给出的四条规则来判定就能得出了。</p><p>首先是获取某一特定坐标的生物有多少活着的邻居，仅需遍历它八个邻居的位置并确定是否存活即可。值得注意的是，对于最外层、邻居不足八个的生物要做特殊的处理，以防数组越界。由于我懒得确定是否越界，就用了一个邪道玩法，如果出现了数组越界的 Exception 就忽略掉它继续访问下一个地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> GetLiveNeighbors(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>int</span>[,] ceil)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> val = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>[] neighbors = { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, -<span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>3</span>; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; <span style=color:#ae81ff>3</span>; j++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!(neighbors[i] == <span style=color:#ae81ff>0</span> &amp;&amp; neighbors[j] == <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> r = (x + neighbors[i]);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> c = (y + neighbors[j]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (ceil[r, c] == <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        val += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>catch</span> (System.Exception)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    val += <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> val;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面则是确定某一坐标下的生物在下一轮中是死是活。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> hang = cells.GetLength(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> lie = cells.GetLength(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> newGen = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[hang + <span style=color:#ae81ff>2</span>, lie + <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> biggerCells = NewBoard(cells);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>; x &lt; hang + <span style=color:#ae81ff>2</span>; x++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> y = <span style=color:#ae81ff>0</span>; y &lt; lie + <span style=color:#ae81ff>2</span>; y++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> n = GetLiveNeighbors(x, y, biggerCells);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> c = biggerCells[x, y];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        newGen[x, y] = ((c == <span style=color:#ae81ff>1</span>) &amp;&amp; (n == <span style=color:#ae81ff>2</span> || n == <span style=color:#ae81ff>3</span>) || (c == <span style=color:#ae81ff>0</span>) &amp;&amp; n == <span style=color:#ae81ff>3</span>) ? <span style=color:#ae81ff>1</span> : <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = cropped(newGen);
</span></span></code></pre></div><p>至于代数，一个递归就能解决问题了。在此不作赘述。</p><h2 id=完整代码>完整代码</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConwayLife</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>[,] GetGeneration(<span style=color:#66d9ef>int</span>[,] cells, <span style=color:#66d9ef>int</span> generation)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (generation &lt;= <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> cells;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> hang = cells.GetLength(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> lie = cells.GetLength(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> newGen = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[hang + <span style=color:#ae81ff>2</span>, lie + <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> biggerCells = NewBoard(cells);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>; x &lt; hang + <span style=color:#ae81ff>2</span>; x++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> y = <span style=color:#ae81ff>0</span>; y &lt; lie + <span style=color:#ae81ff>2</span>; y++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> n = GetLiveNeighbors(x, y, biggerCells);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> c = biggerCells[x, y];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                newGen[x, y] = ((c == <span style=color:#ae81ff>1</span>) &amp;&amp; (n == <span style=color:#ae81ff>2</span> || n == <span style=color:#ae81ff>3</span>) || (c == <span style=color:#ae81ff>0</span>) &amp;&amp; n == <span style=color:#ae81ff>3</span>) ? <span style=color:#ae81ff>1</span> : <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> result = cropped(newGen);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> GetGeneration(result, generation - <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> GetLiveNeighbors(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>int</span>[,] ceil)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> val = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span>[] neighbors = { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, -<span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>3</span>; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; <span style=color:#ae81ff>3</span>; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!(neighbors[i] == <span style=color:#ae81ff>0</span> &amp;&amp; neighbors[j] == <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> r = (x + neighbors[i]);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> c = (y + neighbors[j]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (ceil[r, c] == <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            val += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>catch</span> (System.Exception)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        val += <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> val;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>[,] cropped(<span style=color:#66d9ef>int</span>[,] cells)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> hang = cells.GetLength(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> lie = cells.GetLength(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> (hStart, lStart, hEnd, lEnd, hLen, lLen) = (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hang; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; lie; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cells[i, j] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    hStart = i;
</span></span><span style=display:flex><span>                    i = hang;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = hang - <span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>0</span>; i--)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = lie - <span style=color:#ae81ff>1</span>; j &gt;= <span style=color:#ae81ff>0</span>; j--)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cells[i, j] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    hEnd = i;
</span></span><span style=display:flex><span>                    i = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; lie; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; hang; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cells[j, i] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    lStart = i;
</span></span><span style=display:flex><span>                    i = lie;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = lie - <span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>0</span>; i--)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = hang - <span style=color:#ae81ff>1</span>; j &gt;= <span style=color:#ae81ff>0</span>; j--)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (cells[j, i] != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    lEnd = i;
</span></span><span style=display:flex><span>                    i = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        hLen = hEnd - hStart + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        lLen = lEnd - lStart + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> newCell = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[hLen, lLen];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;h {hLen} l {lLen}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hLen; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; lLen; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                newCell[i, j] = cells[hStart + i, lStart + j];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newCell;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>[,] NewBoard(<span style=color:#66d9ef>int</span>[,] cells)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> hang = cells.GetLength(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> lie = cells.GetLength(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> newBoard = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[hang + <span style=color:#ae81ff>2</span>, lie + <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hang + <span style=color:#ae81ff>2</span>; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; lie + <span style=color:#ae81ff>2</span>; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                newBoard[i, j] = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; hang + <span style=color:#ae81ff>1</span>; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>1</span>; j &lt; lie + <span style=color:#ae81ff>1</span>; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                newBoard[i, j] = cells[i - <span style=color:#ae81ff>1</span>, j - <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newBoard;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.batkiz.com/posts/some-pwsh-scripts/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>一些 powershell 脚本</span></a>
<a class=next href=https://blog.batkiz.com/posts/hugo-ci-v2/><span>Hugo 自动化 CI V2</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.batkiz.com/>not b@tk1z</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "fd2a175921e640c8a40b873fb5e58aaa"}'></script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>